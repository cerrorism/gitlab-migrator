// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGitlabMergeRequest = `-- name: CreateGitlabMergeRequest :one
INSERT INTO gitlab_merge_request (migration_id, mr_iid, merge_commit_sha, parent1_commit_sha, parent2_commit_sha, status) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, migration_id, mr_iid, merge_commit_sha, parent1_commit_sha, parent2_commit_sha, pr_id, status, notes, created_at, updated_at
`

type CreateGitlabMergeRequestParams struct {
	MigrationID      int64
	MrIid            int64
	MergeCommitSha   string
	Parent1CommitSha string
	Parent2CommitSha string
	Status           string
}

func (q *Queries) CreateGitlabMergeRequest(ctx context.Context, arg CreateGitlabMergeRequestParams) (GitlabMergeRequest, error) {
	row := q.db.QueryRow(ctx, createGitlabMergeRequest,
		arg.MigrationID,
		arg.MrIid,
		arg.MergeCommitSha,
		arg.Parent1CommitSha,
		arg.Parent2CommitSha,
		arg.Status,
	)
	var i GitlabMergeRequest
	err := row.Scan(
		&i.ID,
		&i.MigrationID,
		&i.MrIid,
		&i.MergeCommitSha,
		&i.Parent1CommitSha,
		&i.Parent2CommitSha,
		&i.PrID,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllGitLabToGithubMigrationIIDs = `-- name: GetAllGitLabToGithubMigrationIIDs :many
SELECT mr_iid FROM gitlab_merge_request WHERE migration_id = $1
`

func (q *Queries) GetAllGitLabToGithubMigrationIIDs(ctx context.Context, migrationID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllGitLabToGithubMigrationIIDs, migrationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var mr_iid int64
		if err := rows.Scan(&mr_iid); err != nil {
			return nil, err
		}
		items = append(items, mr_iid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableGithubAuthToken = `-- name: GetAvailableGithubAuthToken :one
UPDATE github_auth_token SET status='in_use', updated_at=CURRENT_TIMESTAMP WHERE id = (SELECT id FROM github_auth_token WHERE status = 'available' ORDER BY rate_limit_remaining DESC, id FOR UPDATE SKIP LOCKED LIMIT 1) RETURNING id, auth_type, token, app_id, installation_id, private_key_file, status, rate_limit_remaining, rate_limit_reset, notes, created_at, updated_at
`

func (q *Queries) GetAvailableGithubAuthToken(ctx context.Context) (GithubAuthToken, error) {
	row := q.db.QueryRow(ctx, getAvailableGithubAuthToken)
	var i GithubAuthToken
	err := row.Scan(
		&i.ID,
		&i.AuthType,
		&i.Token,
		&i.AppID,
		&i.InstallationID,
		&i.PrivateKeyFile,
		&i.Status,
		&i.RateLimitRemaining,
		&i.RateLimitReset,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGitLabToGithubMigration = `-- name: GetGitLabToGithubMigration :one
SELECT id, gitlab_project_name, github_repo_name, status, notes, created_at, updated_at FROM gitlab_to_github_migration WHERE status = 'ONGOING' order by id FOR UPDATE SKIP LOCKED limit 1
`

func (q *Queries) GetGitLabToGithubMigration(ctx context.Context) (GitlabToGithubMigration, error) {
	row := q.db.QueryRow(ctx, getGitLabToGithubMigration)
	var i GitlabToGithubMigration
	err := row.Scan(
		&i.ID,
		&i.GitlabProjectName,
		&i.GithubRepoName,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGitlabMergeRequests = `-- name: GetGitlabMergeRequests :many
UPDATE gitlab_merge_request SET status=$3 WHERE id in (SELECT id FROM gitlab_merge_request as gmr WHERE gmr.migration_id = $1 and gmr.status = $4 order by id FOR UPDATE SKIP LOCKED limit $2) RETURNING id, migration_id, mr_iid, merge_commit_sha, parent1_commit_sha, parent2_commit_sha, pr_id, status, notes, created_at, updated_at
`

type GetGitlabMergeRequestsParams struct {
	MigrationID int64
	Limit       int32
	ToState     string
	FromState   string
}

func (q *Queries) GetGitlabMergeRequests(ctx context.Context, arg GetGitlabMergeRequestsParams) ([]GitlabMergeRequest, error) {
	rows, err := q.db.Query(ctx, getGitlabMergeRequests,
		arg.MigrationID,
		arg.Limit,
		arg.ToState,
		arg.FromState,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GitlabMergeRequest
	for rows.Next() {
		var i GitlabMergeRequest
		if err := rows.Scan(
			&i.ID,
			&i.MigrationID,
			&i.MrIid,
			&i.MergeCommitSha,
			&i.Parent1CommitSha,
			&i.Parent2CommitSha,
			&i.PrID,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitlabMergeRequestsWithPRCreated = `-- name: GetGitlabMergeRequestsWithPRCreated :many
UPDATE gitlab_merge_request SET status='ONGOING_DISCUSSION' WHERE id in (SELECT id FROM gitlab_merge_request as gmr WHERE gmr.migration_id = $1 and gmr.status = 'PR_CREATED' order by id FOR UPDATE SKIP LOCKED limit 5000) RETURNING id, migration_id, mr_iid, merge_commit_sha, parent1_commit_sha, parent2_commit_sha, pr_id, status, notes, created_at, updated_at
`

func (q *Queries) GetGitlabMergeRequestsWithPRCreated(ctx context.Context, migrationID int64) ([]GitlabMergeRequest, error) {
	rows, err := q.db.Query(ctx, getGitlabMergeRequestsWithPRCreated, migrationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GitlabMergeRequest
	for rows.Next() {
		var i GitlabMergeRequest
		if err := rows.Scan(
			&i.ID,
			&i.MigrationID,
			&i.MrIid,
			&i.MergeCommitSha,
			&i.Parent1CommitSha,
			&i.Parent2CommitSha,
			&i.PrID,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseGithubAuthToken = `-- name: ReleaseGithubAuthToken :exec
UPDATE github_auth_token SET status='available', updated_at=CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) ReleaseGithubAuthToken(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, releaseGithubAuthToken, id)
	return err
}

const updateGithubAuthTokenRateLimit = `-- name: UpdateGithubAuthTokenRateLimit :exec
UPDATE github_auth_token SET rate_limit_remaining = $1, rate_limit_reset = $2, updated_at=CURRENT_TIMESTAMP WHERE id = $3
`

type UpdateGithubAuthTokenRateLimitParams struct {
	RateLimitRemaining pgtype.Int4
	RateLimitReset     pgtype.Timestamp
	ID                 int64
}

func (q *Queries) UpdateGithubAuthTokenRateLimit(ctx context.Context, arg UpdateGithubAuthTokenRateLimitParams) error {
	_, err := q.db.Exec(ctx, updateGithubAuthTokenRateLimit, arg.RateLimitRemaining, arg.RateLimitReset, arg.ID)
	return err
}

const updateGitlabMergeRequestNotes = `-- name: UpdateGitlabMergeRequestNotes :exec
UPDATE gitlab_merge_request SET notes = $1 WHERE id = $2
`

type UpdateGitlabMergeRequestNotesParams struct {
	Notes string
	ID    int64
}

func (q *Queries) UpdateGitlabMergeRequestNotes(ctx context.Context, arg UpdateGitlabMergeRequestNotesParams) error {
	_, err := q.db.Exec(ctx, updateGitlabMergeRequestNotes, arg.Notes, arg.ID)
	return err
}

const updateGitlabMergeRequestPRID = `-- name: UpdateGitlabMergeRequestPRID :exec
UPDATE gitlab_merge_request SET pr_id = $1, status='PR_CREATED' WHERE id = $2
`

type UpdateGitlabMergeRequestPRIDParams struct {
	PrID int64
	ID   int64
}

func (q *Queries) UpdateGitlabMergeRequestPRID(ctx context.Context, arg UpdateGitlabMergeRequestPRIDParams) error {
	_, err := q.db.Exec(ctx, updateGitlabMergeRequestPRID, arg.PrID, arg.ID)
	return err
}

const updateGitlabMergeRequestStatus = `-- name: UpdateGitlabMergeRequestStatus :exec
UPDATE gitlab_merge_request SET status = $2 WHERE id = $1
`

type UpdateGitlabMergeRequestStatusParams struct {
	ID     int64
	Status string
}

func (q *Queries) UpdateGitlabMergeRequestStatus(ctx context.Context, arg UpdateGitlabMergeRequestStatusParams) error {
	_, err := q.db.Exec(ctx, updateGitlabMergeRequestStatus, arg.ID, arg.Status)
	return err
}
